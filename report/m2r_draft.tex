\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{epstopdf}
\usepackage{setspace}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{relsize}
\usepackage{anysize}
\usepackage{fancyhdr}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{titling}
\usepackage{afterpage}

\newcommand\blankpage{
    \null
    \thispagestyle{empty}
    \newpage
    }

\author{}
\title{\textbf{How does a Computer do Algebra?}}
\date{}
\marginsize{3cm}{3cm}{1.5cm}{1.5cm}
\doublespacing

\begin{document}
\afterpage{\blankpage}

\maketitle
\newpage

\afterpage{\blankpage}
\tableofcontents



\newpage




\section{Introduction}
In this project we will trying to understand how a computer performs symbolic algebra. There already exist many packages that do this, such as sympy in Python, however to understand this fully we will be building our own symbolic package from scratch. Due to time constraints, we will only be covering differentiation and some simple simplification.\\
Firstly we looked at how a computer visualises inputs, in our case mathematical expressions, which it does using abstract syntax trees. Following this we explored various manipulations and functions on the abstract syntax tree and began building our package.


\section{Methods}


\section{Object Oriented Programming \& Package}

Given the aims of our project, our first step was to simply create a program that would consider the Mathematical expression we inputted and find this as an Abstract Syntax Tree (AST) that can both be displayed for a computer using the function repr() or for human reading it using str(). 

Using Python to help us create the program to do this, we soon discovered Object Oriented Programming (OOP). OOP is a way to construct the relationships between various objects, in our case the nodes of the AST of the expression we have inputted. In our ASTs for each expression we had nodes and edges, through OOP we were able to assign specific properties for each node. These properties included a name, symbol and a priority. Since some nodes shared similar properties we, we were able to group certain objects into classes, where all objects falling in a certain class inherit the same properties. When an object is in an particular class we say it is an instance of the class. We started by creating a package called symbolic within which we created a Python module called node.py, where we stored all of our classes which our objects fall into and the methods associated with them. 

We started with a class called nodes, here we could state any properties that would be shared by all nodes and all the methods that were associated with this class. We then realised that all nodes fell into one of two categories: Operators or Terminals. These became our subclasses of node. Now first considering the subclass of operators we know that we have Unary operators such as exp(), -() or sin() and then binary operators such as addition, multiplication, subtraction, division and power. Each of these separate operators forms a subclass of UnaryOperator or BinaryOperator. An example would be the class Add which is a subclass of BinaryOperator. Therefore a node which performs the function add on its operands is an instance of the class nodes, therefore it inherits all properties of the class Add and also its parent class BinaryOperator and BinaryOperator’s parent class Operator and so on. Within the subclass Add we assign the symbol associated with this operation so it can be inherited by nodes that need to be added to other nodes, as these nodes would be objects within the Add class.

To account for the fact that $x + 2 = 2 + x$ for example, we had to introduce reverse operations and state when they would need to be applied instead of the usual \_\_add\_\_. In \_\_add\_\_ the first object is considered to be the self and the second object is the other. In \_\_radd\_\_ it is the opposite, therefore when we return Add(self, other) in \_\_radd\_\_ we are intact swapping the order of the operands in comparison with \_\_add\_\_. The module knew whether to use \_\_add\_\_ or \_\_radd\_\_ by checking whether other, that is our second operand, was a number as this is the only time where the order of operands in the output may need to be switched. We applied the same rules for other commutative operators such as multiply. 

Our other subclass of Nodes was the class Terminal, where we accounted for the most bottom children of our AST, that is nodes that don’t have their own operands. These can only be symbols or numbers so we set these up as the two sub-classes of Terminal. We let each object that was a symbol have a name and each each object that was a number have a value, these could be returned when calling upon self.name, where self is the node currently being considered. 

Within each class we can have magic methods. These are methods which are called upon and apply to all objects in that particular class. First of all we considered what methods all nodes would need to be able to do. Considering a regular node that could be an operator or a terminal, we know that it can be added, multiplied, divided, subtracted or taken to the power of another node. Therefore within the class of Node, our highest class, we can define all of these operations using magic methods. Magic method functions take in arguments self and other, where self is the node being considered and other is the node which it will be operated with. The syntax used to define such a magic method is def \_\_add\_\_(self, other): and then you state what needs to be done then this function is called, in this case return the class of Add(self,other) which tells the node to take the properties of this class which include assigning the appropriate symbol for the operator. 

Now considering the two subclasses of the class Operator, that is BinaryOperator and UnaryOperator, we know that an object within these classes would take operands, hence we initialised each of these classes giving each operands (two and one respectively) and a name. We did this by calling on the magic method \_\_init\_\_. We also defined the method of returning this section of the expression in string form using \_\_str\_\_ for a person to be able to read it as during the process of going through the classes the expression is stored in object form. Although we have to initialise both classes, we could not do this in the parent class Operator since in UnaryOperator and BinaryOperator a different number of operands need to be considered. If we had instead defined it in the parent class it would automatically be inherited by both subclasses and therefore have the wrong number of operands for one of the subclasses. 

Parenthese 















\end{document}
